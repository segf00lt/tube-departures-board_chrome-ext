{
  "version": 3,
  "sources": ["browser-external:stream", "../../csv-parser/index.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"stream\" has been externalized for browser compatibility. Cannot access \"stream.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "const { Transform } = require('stream')\n\nconst [cr] = Buffer.from('\\r')\nconst [nl] = Buffer.from('\\n')\nconst defaults = {\n  escape: '\"',\n  headers: null,\n  mapHeaders: ({ header }) => header,\n  mapValues: ({ value }) => value,\n  newline: '\\n',\n  quote: '\"',\n  raw: false,\n  separator: ',',\n  skipComments: false,\n  skipLines: null,\n  maxRowBytes: Number.MAX_SAFE_INTEGER,\n  strict: false\n}\n\nclass CsvParser extends Transform {\n  constructor (opts = {}) {\n    super({ objectMode: true, highWaterMark: 16 })\n\n    if (Array.isArray(opts)) opts = { headers: opts }\n\n    const options = Object.assign({}, defaults, opts)\n\n    options.customNewline = options.newline !== defaults.newline\n\n    for (const key of ['newline', 'quote', 'separator']) {\n      if (typeof options[key] !== 'undefined') {\n        ([options[key]] = Buffer.from(options[key]))\n      }\n    }\n\n    // if escape is not defined on the passed options, use the end value of quote\n    options.escape = (opts || {}).escape ? Buffer.from(options.escape)[0] : options.quote\n\n    this.state = {\n      empty: options.raw ? Buffer.alloc(0) : '',\n      escaped: false,\n      first: true,\n      lineNumber: 0,\n      previousEnd: 0,\n      rowLength: 0,\n      quoted: false\n    }\n\n    this._prev = null\n\n    if (options.headers === false) {\n      // enforce, as the column length check will fail if headers:false\n      options.strict = false\n    }\n\n    if (options.headers || options.headers === false) {\n      this.state.first = false\n    }\n\n    this.options = options\n    this.headers = options.headers\n  }\n\n  parseCell (buffer, start, end) {\n    const { escape, quote } = this.options\n    // remove quotes from quoted cells\n    if (buffer[start] === quote && buffer[end - 1] === quote) {\n      start++\n      end--\n    }\n\n    let y = start\n\n    for (let i = start; i < end; i++) {\n      // check for escape characters and skip them\n      if (buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote) {\n        i++\n      }\n\n      if (y !== i) {\n        buffer[y] = buffer[i]\n      }\n      y++\n    }\n\n    return this.parseValue(buffer, start, y)\n  }\n\n  parseLine (buffer, start, end) {\n    const { customNewline, escape, mapHeaders, mapValues, quote, separator, skipComments, skipLines } = this.options\n\n    end-- // trim newline\n    if (!customNewline && buffer.length && buffer[end - 1] === cr) {\n      end--\n    }\n\n    const comma = separator\n    const cells = []\n    let isQuoted = false\n    let offset = start\n\n    if (skipComments) {\n      const char = typeof skipComments === 'string' ? skipComments : '#'\n      if (buffer[start] === Buffer.from(char)[0]) {\n        return\n      }\n    }\n\n    const mapValue = (value) => {\n      if (this.state.first) {\n        return value\n      }\n\n      const index = cells.length\n      const header = this.headers[index]\n\n      return mapValues({ header, index, value })\n    }\n\n    for (let i = start; i < end; i++) {\n      const isStartingQuote = !isQuoted && buffer[i] === quote\n      const isEndingQuote = isQuoted && buffer[i] === quote && i + 1 <= end && buffer[i + 1] === comma\n      const isEscape = isQuoted && buffer[i] === escape && i + 1 < end && buffer[i + 1] === quote\n\n      if (isStartingQuote || isEndingQuote) {\n        isQuoted = !isQuoted\n        continue\n      } else if (isEscape) {\n        i++\n        continue\n      }\n\n      if (buffer[i] === comma && !isQuoted) {\n        let value = this.parseCell(buffer, offset, i)\n        value = mapValue(value)\n        cells.push(value)\n        offset = i + 1\n      }\n    }\n\n    if (offset < end) {\n      let value = this.parseCell(buffer, offset, end)\n      value = mapValue(value)\n      cells.push(value)\n    }\n\n    if (buffer[end - 1] === comma) {\n      cells.push(mapValue(this.state.empty))\n    }\n\n    const skip = skipLines && skipLines > this.state.lineNumber\n    this.state.lineNumber++\n\n    if (this.state.first && !skip) {\n      this.state.first = false\n      this.headers = cells.map((header, index) => mapHeaders({ header, index }))\n\n      this.emit('headers', this.headers)\n      return\n    }\n\n    if (!skip && this.options.strict && cells.length !== this.headers.length) {\n      const e = new RangeError('Row length does not match headers')\n      this.emit('error', e)\n    } else {\n      if (!skip) this.writeRow(cells)\n    }\n  }\n\n  parseValue (buffer, start, end) {\n    if (this.options.raw) {\n      return buffer.slice(start, end)\n    }\n\n    return buffer.toString('utf-8', start, end)\n  }\n\n  writeRow (cells) {\n    const headers = (this.headers === false) ? cells.map((value, index) => index) : this.headers\n\n    const row = cells.reduce((o, cell, index) => {\n      const header = headers[index]\n      if (header === null) return o // skip columns\n      if (header !== undefined) {\n        o[header] = cell\n      } else {\n        o[`_${index}`] = cell\n      }\n      return o\n    }, {})\n\n    this.push(row)\n  }\n\n  _flush (cb) {\n    if (this.state.escaped || !this._prev) return cb()\n    this.parseLine(this._prev, this.state.previousEnd, this._prev.length + 1) // plus since online -1s\n    cb()\n  }\n\n  _transform (data, enc, cb) {\n    if (typeof data === 'string') {\n      data = Buffer.from(data)\n    }\n\n    const { escape, quote } = this.options\n    let start = 0\n    let buffer = data\n\n    if (this._prev) {\n      start = this._prev.length\n      buffer = Buffer.concat([this._prev, data])\n      this._prev = null\n    }\n\n    const bufferLength = buffer.length\n\n    for (let i = start; i < bufferLength; i++) {\n      const chr = buffer[i]\n      const nextChr = i + 1 < bufferLength ? buffer[i + 1] : null\n\n      this.state.rowLength++\n      if (this.state.rowLength > this.options.maxRowBytes) {\n        return cb(new Error('Row exceeds the maximum size'))\n      }\n\n      if (!this.state.escaped && chr === escape && nextChr === quote && i !== start) {\n        this.state.escaped = true\n        continue\n      } else if (chr === quote) {\n        if (this.state.escaped) {\n          this.state.escaped = false\n          // non-escaped quote (quoting the cell)\n        } else {\n          this.state.quoted = !this.state.quoted\n        }\n        continue\n      }\n\n      if (!this.state.quoted) {\n        if (this.state.first && !this.options.customNewline) {\n          if (chr === nl) {\n            this.options.newline = nl\n          } else if (chr === cr) {\n            if (nextChr !== nl) {\n              this.options.newline = cr\n            }\n          }\n        }\n\n        if (chr === this.options.newline) {\n          this.parseLine(buffer, this.state.previousEnd, i + 1)\n          this.state.previousEnd = i + 1\n          this.state.rowLength = 0\n        }\n      }\n    }\n\n    if (this.state.previousEnd === bufferLength) {\n      this.state.previousEnd = 0\n      return cb()\n    }\n\n    if (bufferLength - this.state.previousEnd < data.length) {\n      this._prev = data\n      this.state.previousEnd -= (bufferLength - data.length)\n      return cb()\n    }\n\n    this._prev = buffer\n    cb()\n  }\n}\n\nmodule.exports = (opts) => new CsvParser(opts)\n"],
  "mappings": "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",
  "names": []
}
